"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  /**
   * Runs the task and each of it's children's tasks.
   *
   * It first runs it's own element's exec() method if one exists; when it's
   * own Promise resolves it runs each of it's child elements' start()
   * methods in series, unless the property parallelTasks is set to true on it's
   * component instance, in which case they will run in parallel.
   *
   * Introduces two new lifecycle methods componentWillExec() and
   * componentDidExec(). If componentWillExec() is defined it will be called
   * before it's own exec() method is called. If componentDidExec() is defined
   * it will be called after it's own exec() method has resolved and after
   * each of it's child elements' start() methods have resolved.
   *
   * It's important to note that the start() method is an internal construct
   * while exec(), componentWillExec(), and componentDidExec() are part of the
   * React component representing the task. An inheritor will never need to
   * implement a start() method, and if they do it will never be called by the
   * internals of React Pipeline.
   * @return Promise
   */
  start: function start() {
    var _this = this;

    var inst = this._instance;

    if (inst && inst.componentWillExec) {
      inst.componentWillExec();
    }

    var exec = inst && inst.exec ? inst.exec.bind(inst) : function () {
      return Promise.resolve();
    };
    var forceUpdate = inst && inst.forceUpdate ? inst.forceUpdate.bind(inst) : function (cb) {
      return cb();
    };

    return exec().then(function () {
      return new Promise(function (resolve, reject) {
        forceUpdate(function () {
          var children = [];
          var renderedChildren = _this._renderedChildren;

          if (_this._renderedComponent) {
            if (_this._renderedComponent._instance && _this._renderedComponent._instance.exec) {
              children.push(_this._renderedComponent);
            } else if (_this._renderedComponent._renderedChildren) {
              renderedChildren = _this._renderedComponent._renderedChildren;
            }
          }

          if (renderedChildren) {
            for (var key in renderedChildren) {
              var child = renderedChildren[key];
              children.push(child);
            }
          }

          if (children.length === 0) {
            if (inst && inst.componentDidExec) {
              inst.componentDidExec();
            }
            return resolve();
          }

          if (inst && inst.props.parallelTasks === true) {
            Promise.all(children.map(function (c) {
              return c.start();
            })).then(function () {
              if (inst && inst.componentDidExec) {
                inst.componentDidExec();
              }
            }).then(resolve).catch(reject);
          } else {
            children.reduce(function (cur, next) {
              return cur.then(next.start.bind(next));
            }, Promise.resolve()).then(function () {
              if (inst && inst.componentDidExec) {
                inst.componentDidExec();
              }
            }).then(resolve).catch(reject);
          }
        });
      });
    });
  }
};